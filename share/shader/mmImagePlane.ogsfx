// Copyright (C) 2021, 2023, 2024 David Cattermole.
//
// This file is part of mmSolver.
//
// mmSolver is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// mmSolver is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with mmSolver.  If not, see <https://www.gnu.org/licenses/>.
// --------------------------------------------------------------------
//
// Draw a texture on an image plane.

// Global variables provided by Maya.
uniform mat4 gWVPXf : WorldViewProjection;

// The solid color uniform, its default value and several extra
// parameters
uniform vec4 gSolidColor : DIFFUSE = {1, 1, 1, 1};

uniform float gColorGain = 1.0f;
uniform float gAlphaGain = 1.0f;
uniform float gColorGamma = 1.0f;
uniform bool gIgnoreAlpha = false;
uniform bool gFlip = false;
uniform bool gFlop = false;
uniform bool gShowChannelRed = false;
uniform bool gShowChannelGreen = false;
uniform bool gShowChannelBlue = false;
uniform bool gShowChannelAlpha = false;

// The main image texture displaying RGBA values to the user.
uniform texture2D gImageTexture
<
    string ResourceName = "";
    string ResourceType = "2D";
>;

uniform sampler2D gImageTextureSampler = sampler_state
{
    Texture = <gImageTexture>;
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
    TEXTURE_WRAP_R = CLAMP_TO_EDGE;
};


// Vertex Shader inputs.
attribute VS_INPUT {
    vec3 Pos : POSITION;
    vec2 UV : TEXCOORD0;
};

// Vertex Shader data outputs, to be used by the Pixel Shader.
attribute SHADER_DATA {
    vec2 UV;
};

// Vertex Shader
GLSLShader VS_mmImagePlane {
    void main() {
        gl_Position = gWVPXf * vec4(Pos, 1);

        vec2 uv = UV;
        if (gFlop) {
            uv.x -= 0.5f;
            uv.x *= -1.0f;
            uv.x += 0.5f;
        }

        if (gFlip) {
            uv.y -= 0.5f;
            uv.y *= -1.0f;
            uv.y += 0.5f;
        }

        VS_OUTPUT.UV = uv;
    }
}

// Pixel Shader Outputs
attribute PIXEL_DATA {
    vec4 colorOut : COLOR0;
}

GLSLShader PS_mmImagePlane_Main {
    void main() {
        vec4 texture_color = texture2D(gImageTextureSampler, PS_INPUT.UV);
        if (gIgnoreAlpha) {
            texture_color.a = 1.0f;
        }

        vec3 gamma = vec3(gColorGamma, gColorGamma, gColorGamma);
        texture_color.rgb = max(vec3(0.0f, 0.0f, 0.0f), texture_color.rgb);
        texture_color.rgb = pow(texture_color.rgb, (1.0f / gamma));

        texture_color.r *= gColorGain;
        texture_color.g *= gColorGain;
        texture_color.b *= gColorGain;
        texture_color.a *= gAlphaGain;

        if (texture_color.a > 1.0f) {
            texture_color.a = 1.0f;
        } else if (texture_color.a < 0.0f) {
            texture_color.a = 0.0f;
        }

        colorOut = gSolidColor * texture_color;
        if (gShowChannelRed) {
            colorOut = vec4(colorOut.r, colorOut.r, colorOut.r, 1.0f);
        } else if (gShowChannelGreen) {
            colorOut = vec4(colorOut.g, colorOut.g, colorOut.g, 1.0f);
        } else if (gShowChannelBlue) {
            colorOut = vec4(colorOut.b, colorOut.b, colorOut.b, 1.0f);
        } else if (gShowChannelAlpha) {
            colorOut = vec4(colorOut.a, colorOut.a, colorOut.a, 1.0f);
        }
    }
}

technique Main
<
// Tell Maya to support transparency for this technique.
string Transparency = "Transparent"; // or "Opaque".
>
{
    pass p0 {
        VertexShader(in VS_INPUT, out SHADER_DATA VS_OUTPUT) = VS_mmImagePlane;
        PixelShader(in SHADER_DATA PS_INPUT, out PIXEL_DATA) = PS_mmImagePlane_Main;
    }
}
